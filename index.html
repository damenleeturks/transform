<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Transform string</title>
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script> -->

    <style id="jsbin-css">
      * {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
        box-sizing: border-box;
        font-size: 18px;
      }

      body {
        background: #fefefe;
        margin: 0;
      }

      textarea {
        display: block;
        width: 100%;
        height: 20vh;
      }

      li {
        margin: 4px 0;
      }

      .rule>span:first-child {
        width: 30%;
      }

      .delete {
        margin-right: 10px;
      }

      button {
        border-radius: 2px;
        cursor: pointer;
      }

      button:hover {
        background: rgba(1, 1, 1, 0.1)
      }

      #rules ol {
        overflow: hidden;
      }

      .add-rule {
        margin: 20px 0;
        display: block;
        clear: both;
      }

      .rule span:last-child {
        color: rgb(154, 154, 154);
        /* background: white; */
      }

      #app {
        padding: 20px;
        padding-top: 0;
      }

      @media screen and (min-width: 900px) {
        div#app {
          display: grid;
          grid-column-gap: 20px;
          grid-row-gap: 0px;
          grid-template-columns: repeat(2, minmax(200px, 1fr));
        }
      }


      #app> :nth-child(1) {
        grid-area: 3 / 1 / 4 / 2;
      }

      #app> :nth-child(2) {
        grid-area: 4 / 1 / 5 / 2;
      }

      #app> :nth-child(3) {
        grid-area: 1 / 1 / 2 / 2;
      }

      #app> :nth-child(4) {
        grid-area: 2 / 1 / 3 / 2;
      }

      #app> :nth-child(5) {
        grid-row: auto / span 1;
      }

      #app> :nth-child(6) {
        grid-row: auto / span 5;
      }

      pre {
        white-space: pre-wrap;
        color: #212121;
        font-family: 'ubuntu mono', Consolas, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New;

      }

      button.delete {
        background: none;
        border: 0;
        margin: 0;
      }

      button.delete:after {
        opacity: 0.5;
        content: 'üóëÔ∏è';
        color: black;
        font-size: initial;
      }

      button.delete {
        color: transparent;
        font-size: 0;
      }

      button.delete:hover:after {
        opacity: 1;
      }

      textarea#source {
        width: 100% !important;
        padding: 8px;
        font-size: 100%;
        opacity: 0.5;
      }

      header {
        display: flex;
        justify-content: space-between;
        padding: 20px;
        background: rgb(158, 158, 158);
        font-weight: bold;
        color: #fefefe;
        margin-bottom: 20px;
      }

      header a {
        color: #fff;
      }

      header p {
        margin: 0;
      }

      header p:last-child {
        margin-left: 20px;
      }

      .error input {
        background: #FFCDD2;
      }

      .copy {
        border: 0;
        background: none;
        text-decoration: underline;
        font-weight: normal;
        margin-left: 8px;
        border-radius: 2px;
        color: #999;
      }

      .copy:hover {
        color: #000;
      }

      /* I feel utterly ashamed of myself for doing this‚Ä¶ */
      .copy:after {
        content: 'y';
      }

      .copy:active:after {
        content: 'ied';
      }
    </style>
  </head>

  <body>
    <header>
      <p>Transform a glob of text into structured JSON</p>
      <p>Created by <a target="_blank" href="https://remysharp.com">@rem</a> &bull; <a target="_blank" href="https://remysharp.com/work">Work with
          me</a></p>
    </header>
    <div id="app">
      <h2>
        Source
      </h2>
      <textarea v-model="source" id="source" placeholder="paste a glob of text here"></textarea>

      <h2>
        Transform rules
      </h2>

      <div id="rules">
        <ol>
          <li v-for="(rule, index) in rules">
            <button class="delete" v-on:click="deleteRule(index)">
              delete
            </button>
            <label class="rule" v-bind:class="{ error: index === error}">
              <span>{{ rule.type | labelForRule }}</span>
              <span v-show="rule.value !== null"><input v-model="rule.value" type="text"> ({{ rule.value | display }})
              </span>
            </label>
        </ol>

        <div class="add-rule">
          <label><span>Add rule</span>
            <select v-model="newRule">
              <option value="splitter">Splitter</option>
              <option value="ignore">Ignore match</option>
              <option value="strip">Strip match</option>
              <option value="replace">Replacer</option>
              <option value="map">Map to object</option>
              <option value="trim">Trim</option>
              <option value="dropEmpty">Drop empty</option>
            </select>
          </label>
          <button v-on:click="rules.push({ type: newRule, value: defaultForRule(newRule) })">
            Create
          </button>

        </div>
      </div>

      <h2>
        Result

        <button class="copy" v-on:click="navigator.clipboard.writeText(JSON.stringify(result, 0, 2))"><span aria-label="copy">cop</span></button>
      </h2>
      <pre>{{ result }}</pre>
    </div>


    <!--boot js-->
    <script id="jsbin-javascript" defer>
      function applyRule(result, rule) {
        return result.reduce((acc, curr) => {
          if (Array.isArray(curr)) {
            if (rule.type === 'dropEmpty' && curr.length === 0) {
              return acc;
            }


            if (rule.type === 'map') {
              const fields = rule.value.split(',').map(_ => _.trim());
              curr = curr.reduce((acc, curr, i) => {
                acc[fields[i]] = curr;
                return acc;
              }, {});
              acc.push(curr);
              return acc;
            }

            acc.push(applyRule(curr, rule));
            return acc;
          }

          if (typeof curr === 'object') {
            if (rule.type === 'dropEmpty' && Object.keys(curr).length === 0) {
              return acc;
            }

            curr = Object.entries(curr).reduce((acc, [key, value]) => {
              const res = applyRule([value], rule);
              if (res.length) {
                acc[key] = res[0]
              }
              return acc;
            }, {});
            acc.push(curr);
            return acc;
          }

          if (rule.type === 'dropEmpty') {
            if (!curr || (typeof curr === 'string' && !curr.trim())) {
              return acc;
            }

            acc.push(curr);
            return acc;
          }

          if (rule.type === 'trim') {
            curr = curr.trim();
          }

          if (rule.type === 'splitter') {
            curr = curr.split(rule.value);
          }

          if (rule.type === 'replace') {
            const parts = rule.value.split('/').slice(1, -1);
            if (parts[0] === undefined) parts[0] = '';
            if (parts[1] === undefined) parts[1] = '';
            curr = curr.replace(new RegExp(parts[0], 'g'), parts[1]);
            acc.push(curr);
            return acc;
          }

          if (rule.type === 'strip') {
            let value = rule.value;
            if (value.startsWith('/')) {
              value = rule.value.slice(1, -1);
            }

            curr = curr.replace(new RegExp(value, 'g'), "");
            acc.push(curr);
            return acc;
          }

          if (rule.type === 'ignore' && rule.value) {
            if (rule.value.startsWith('/')) {
              let value = rule.value.slice(1, -1);
              if (new RegExp(value).test(curr)) {
                return acc;
              }
            } else {
              if (curr.includes(rule.value)) {
                return acc;
              }
            }
          }

          acc.push(curr);
          return acc;
        }, [])
      }

      const app = new Vue({
        el: '#app',
        filters: {
          display(s) {
            return JSON.stringify(s)
          },
          labelForRule(type) {
            return {
              splitter: 'Split lines by',
              ignore: 'Ignore if matches',
              dropEmpty: 'Drop empty elements',
              strip: 'Strip matching',
              map: 'Map array to object',
              trim: 'Trim whitespace',
              replace: 'Replace /source/with/'
            }[type]
          }
        },
        data: {
          source: document.querySelector('#source').value,
          newRule: 'splitter',
          rules: [],
          error: null,
        },
        computed: {
          result() {
            this.updateURL();
            const rules = this.rules;
            let result = this.source.split('\n');
            this.error = null;
            // noprotect
            let i = 0;
            try {
              for (i = 0; i < rules.length; i++) {
                const rule = rules[i];
                result = applyRule(result, rule);
              }
            } catch (e) {
              this.error = i;
              console.log('failed at rule %s', i)
            }

            return result
          }
        },
        beforeMount() {
          const url = new URL(window.location);
          this.rules = Array.from(url.searchParams.entries(), (([type, value]) => {
             return ({ type, value: value === 'null' ? null : value })
          }));
        },
        methods: {
          updateURL() {
            const p = new URLSearchParams(this.rules.reduce((acc, curr) => {
              acc.push([curr.type, curr.value]);
              return acc;
            }, []))

            history.replaceState({}, '', '?' + p.toString());
          },
          deleteRule(index) {
            this.rules.splice(index, 1);
          },
          defaultForRule(type) {
            const res = {
              splitter: '\t',
              map: 'prop1, prop2',
              dropEmpty: null,
              trim: null,
              replace: '///'
            }[type]
            return res !== undefined ? res : ''
          },
        }
      })
    </script>
  </body>

</html>
